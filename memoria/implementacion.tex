\section{Implementaci'on}
\label{sec:implementacion}


%%%%%%%%%%%%%%

\subsection{Tecnolog'ias y herramientas}
\label{sec:tecnologias_y_herramientas}

Elegir las herramientas que usar'iamos en el proyecto no fue en muchos casos una tarea sencilla. En inform'atica en general,
y en especial en el 'area de desarrollo web, aparecen cada d'ia muchas herramientas nuevas que cubren necesidades parecidas,
que solapan en cuanto a utilidad o que atacan al mismo problema desde otro punto de vista. Es por esto que
invertimos una gran parte del tiempo en estudiar las distintas tecnolog'ias disponibles para poder decantarnos por algunas
de ellas. En algunas ocasiones no hemos encontrado una herramienta claramente superior a otra, por lo que nuestra decisi'on
final se basa en cu'al nos ha llamado m'as la atenci'on o cu'al consideramos que ser'a m'as 'util en un futuro.

\subsubsection{Programaci'on front y back-end}
\label{sub:programacion_front_y_back_end}
%javascript
%nodejs

La primera elecci'on que nos tuvimos que plantear fue el lenguaje de programaci'on, puesto que esto afectar'ia considerablemente
la direcci'on que iba a tomar el proyecto. 

\begin{itemize}
\item Front-end
\begin{center}
\includegraphics[width=0.25\textwidth]{javascript}
\end{center}

Por una parte, puesto que nuestra idea era crear aplicaciones online, necesit'abamos un
lenguaje apto para ser ejecutado en un navegador web, con lo que nos dejaba con pocas opciones en el lado del cliente. Entre estas
opciones estaba Javascript, un lenguaje potente y bien documentado con una sintaxis que nos resultaba bastante familiar. Aunque existen
otras alternativas como ActionScript o Dart, nuestra decisi'on en este aspecto estaba clara. 

\item Back-end
\begin{center}
\includegraphics[width=0.4\textwidth]{nodejs}
\end{center}

Por otra parte, en cuanto a la programaci'on en el lado del servidor, nosotros ten'iamos cierta experiencia con PHP, pero lo
consider'abamos un lenguaje algo anticuado y poco llamativo, por lo que intentamos buscar otras alternativas. Dos opciones interesantes
fueron Ruby, con su framework Ruby-On-Rails\footnote{\url{http://rubyonrails.org}}, y Python con Django\footnote{\url{https://www.djangoproject.com}}. A decir verdad, aunque los primeros est'an muy extendidos en el
mundo del desarrollo web, nos interesamos m'as por los segundos, que eran algo m'as novedosos y llamativos.

Sin embargo, cuando nos encontr'abamos en medio del estudio de las posibilidades que nos ofrec'ia Django, descubrimos de manera fortuita
Node.js\footnote{\url{http://nodejs.org}} y, aunque no era una herramienta tan madura como Ruby-On-Rails o Django, su r'apido crecimiento y algunas otras caracter'isticas
hicieron que nos decant'aramos por esta nueva opci'on sin dudarlo.

Lo que m'as nos gust'o de Node.js e hizo que lo eligi'eramos de inmediato es que, en el fondo, es simplemente Javascript. Un
Javascript ejecutado en el lado del servidor mediante el motor JS-V8\footnote{\url{https://developers.google.com/v8}} de Google, lo cual permite utilizar un modelo as'incrono y dirigido
por eventos que podr'a, entre otras cosas, mantener muchas conexiones al servidor abiertas y esperando sin bloquearse y consumiendo menos
recursos de la m'aquina. Adem'as, ya se han dado casos de grandes empresas que utilizan Node.js en parte de sus servicios, como es el caso de
LinkedIn\footnote{\url{https://www.linkedin.com}}, los cuales mudaron parte de su c'odigo de Ruby-On-Rails a Node.js permiti'endoles pasar de 30 a 3 servidores necesarios, entre otras
mejoras \cite{linkedin_nodejs} .

Otro punto a favor de Node.js es su gestor de paquetes NPM\footnote{\url{https://www.npmjs.org}}, con el cual se puede instalar cualquier extensi'on para back-end que exista en el repositorio
de forma r'apida y sencilla. Como se ha mencionado antes, Node.js est'a teniendo un crecimiento extremadamente r'apido, de forma que el n'umero
de m'odulos existentes para esta tecnolog'ia est'a superando a otros gigantes del sector en muy poco tiempo de vida\footnote{\url{http://modulecounts.com/}}.
Pero, sobretodo, lo m'as importante es que el tiempo que se invierte en la programaci'on de front o back-end
tambi'en nos da experiencia en la otra parte, puesto que siempre estamos usando el mismo lenguaje.

\item Aplicaciones m'oviles
\begin{center}
\includegraphics[width=0.4\textwidth]{phonegap}
\end{center}

Con el reciente auge del smartphone no se pod'ia pasar por alto el hecho de que si nuestras aplicaciones no llegan a dispositivos m'oviles
estar'iamos perdiendo una gran parte del p'ublico potencial. Es por esto que, aunque en este PFC no hemos desarrollado nada centrado en
este tema, s'i que hemos buscado qu'e posibilidades exist'ian para solventar este problema. Siguiendo la misma filosof'ia mostrada en las
secciones anteriores, encontramos una herramienta llamada PhoneGap\footnote{\url{http://phonegap.com}} que permite crear aplicaciones m'oviles usando simplemente Javascript y
HTML5, sin necesidad de invertir tiempo en aprender tecnolog'ias especializadas para cada plataforma m'ovil, como Android, iOS o Windows Phone.

Encontramos, en definitiva, una raz'on m'as para elegir Javascript como piedra angular del proyecto.


\end{itemize}


\subsubsection{Web Application Framework}
\label{sub:web_application_framework}
%expressjs
Es aconsejable el uso de un back-end web framework para facilitar la creaci'on de aplicaciones web. Aunque se puede utilizar Node.js sin m'as,
esto nos obligar'ia a tener que implementar muchas tareas repetibles que ya han sido solucionadas y optimizadas en estos frameworks web.

\begin{center}
\includegraphics[width=0.5\textwidth]{express}
\end{center}

El rey por excelencia en este 'ambito es Express.js\footnote{\url{http://expressjs.com}}, el cual ayudar'a en la organizaci'on de las aplicaciones web ofreciendo una arquitectura
Model-View-Controller. Adem'as, se encargar'a de las rutas de la aplicaci'on, de las peticiones a la base de datos, gesti'on de cookies,
facilidades con motores de plantillas como Jade o Handlebars y de otras muchas caracter'isticas (middlewares).

Crear una aplicaci'on con Express.js es una tarea muy sencilla:

\begin{verbatim}
var express = require('express');
var app = express();

var server = app.listen(3000, function() {
    console.log('Listening on port %d', server.address().port);
});
\end{verbatim}


A modo de ejemplo, una forma de establecer rutas con Express.js ser'ia de la siguiente forma:
\begin{verbatim}
app.get('/', routes.index);
app.get('/words',applications.game1);
\end{verbatim}

Como puede observarse, esto facilita mucho el camino a la hora de crear aplicaciones REST.

\subsubsection{Boilerplate}
\label{sub:boilerplate}
Boilerplate son las secciones de c'odigo que se repiten entre proyectos con pocas o ninguna alteraci'on. En nuestro caso, es un c'odigo repetible
que se encarga de las funcionalidades m'as b'asicas, con lo que sirve de plantilla o gu'ia para empezar una nueva aplicaci'on. Express.js posee
una funci'on de generador de aplicaciones b'asicas que podr'ia considerarse algo parecido a lo anterior.

Al principio de este proyecto se utiliz'o la estructura de c'odigo que proporciona Express.js por defecto para poder empezar a desarrollar las aplicaciones
cuanto antes posible. Sin embargo, esta plantilla por defecto de Express.js no est'a preparada para el uso de herramientas extra que nuestro proyecto debe utilizar,
tales como esquemas y modelos para el controlador de conexi'on a la base de datos o las funciones de comunicaci'on entre cliente y servidor. As'i, tiempo
despu'es de estar trabajando con este modelo encontramos ciertas limitaciones y caracter'isticas que no terminaron de gustarnos. Y, puesto que
queremos hacer de \Nipponline{} un proyecto colaborativo donde desarrolladores externos puedan participar, deb'iamos organizar nuestro c'odigo de la
mejor manera posible para hacerlo entendible. Fue entonces cuando pensamos que quiz'a ser'ia mejor buscar alternativas y consejos de desarrolladores
m'as avanzados. Despu'es de mucho buscar, finalmente encontramos el Boilerplate que proporciona Jason Krol en su blog\cite{jkrol}.

Este Boilerplate propone el uso de un conjunto de herramientas muy completo, muchas de las cuales ya estamos usando en el proyecto, con lo cual ya sabemos
que se adec'ua a lo que tenemos, y otras completamente nuevas para nosotros. La mayor'ia de estas nuevas herramientas nos han parecido tan interesantes que
las hemos estudiado para usarlas en el proyecto m'as adelante:

\begin{itemize}
 \item Back-end: Node.js, Express.js, Handlebars
 
	Testeo: Mocha, Chai, Sinon, Proxyquire
	
 \item Base de datos: MongoDB y MongooseJS
 
 \item Utilidades: Grunt, Bower, Browserify
 
 \item Front-end: Backbone.js, Marionette.js
 
	Testeo: Jasmine, Karma, PhantomJS
	
\end{itemize}

Especialmente interesantes son las utilidades, las cuales no conoc'iamos hasta encontrar este Boilerplate. Bower es un instalador de m'odulos para front-end
(jQuery, underscore, etc), de la misma forma que NPM lo es para Node.js en back-end. Por su parte, Browserify permite desarrollar el c'odigo front-end con un
estilo modular, de forma que estos m'odulos se usen exactamente de la misma forma que se usan los m'odulos en Node.js. Por 'ultimo, Grunt es la m'as interesante
de todas: permite crear un ``script'' para automatizar todas las tareas necesarias antes ejecutar el proyecto, tales como instalar dependencias, testeo (TDD),
uglify, concatenaci'on de archivos, comprimir (minify), transformar LESS/SASS a CSS, ejecutar Node.js y cualquier otra tarea necesaria.

Adoptar este Boilerplate supuso rehacer y reorganizar la mayor'ia del c'odigo que ya ten'iamos en el proyecto, por lo que no fue una tarea sencilla ni r'apida.
No obstante, consideramos que ha sido un acierto puesto que ahora tenemos una estructura m'as organizada para que el c'odigo sea m'as intuitivo para colaboradores
externos y para nosotros mismos.

A medida que nuestro proyecto avanza ir'a incorporando el uso de estas herramientas y tecnolog'ias, como por ejemplo Handlebars para hacer templates de HTML o Mocha y Chai
para temas de TDD (Test-Driven-Development). Ahora s'i, la estructura y organizaci'on de c'odigo que usa este proyecto es por fin compatible con todas estas
herramientas.



\subsubsection{Base de datos}
\label{sub:base_de_datos}
%nosql
Una de las partes m'as importantes de este proyecto es la base de datos. Describir el idioma
japon'es de forma que podamos almacenar tanta informaci'on sobre sus s'ilabas y palabras
como sea posible en una base de datos no es una tarea sencilla. Antes de empezar con el dise'no
realizamos un estudio de las distintas alternativas de bases de datos que exist'ian para poder
escoger la que m'as se adaptara a nuestras necesidades. Hasta este proyecto solamente ten'iamos
experiencia en el uso de bases de datos relacionales como MySQL\footnote{\url{http://www.mysql.com}}, PostgreSQL\footnote{\url{http://www.postgresql.org}} o MariaDB\footnote{\url{https://mariadb.org}}, pero
siempre hemos tenido cierta inquietud por saber qu'e era aquello del ``NoSQL''.

Somos partidarios del uso de bases de datos relacionales
para almacenar ``datos relacionales'', pero en esta ocasi'on pensamos que quiz'a nuestros
datos no se adaptar'ian bien a una forma de tabla estricta. Por lo tanto, llegamos a la
conclusi'on de que le sacar'iamos m'as partido a una base de datos NoSQL por varios motivos,
siendo el m'as importante que en esta base de datos tendr'iamos que describir un lenguaje
complejo, ambiguo y con una inmensa cantidad de excepciones y cosas poco comunes como es
el japon'es. En una base de datos relacional se nos presentar'ian ciertas limitaciones que,
aunque subsanables, posiblemente ser'ian poco elegantes.

\vspace{2em}
\begin{center}
\includegraphics[width=0.5\textwidth]{nosql}
\end{center}

En las bases de datos relacionales, aunque cada una tiene su peculiaridad, todas comparten
el mismo fundamento, por lo que no es tan complicado elegir entre ellas. Sin embargo, existen
muchos tipos diferentes de bases de datos NoSQL, por lo que debemos elegir una
bas'andonos en nuestras necesidades, forma de trabajar, software de terceros que utilicemos e
incluso en el hardware que disponemos.

Las bases de datos NoSQL se pueden clasificar de diferentes maneras, aunque en general se consideran
cuatro tipos de ellas. A saber:

\begin{itemize}
 \item Orientadas a documentos.
 Suelen contener datos semi-estructurados organizados en forma de documentos. El formato de dichos
 documentos suele ser un est'andar como XML, YAML o JSON (o BSON, JSON en binario). En general, son las bases
 de datos NoSQL m'as vers'atiles, pudiendo formar parte de proyectos muy diversos. Compar'andolo
 con bases de datos relacionales, los documentos se almacenan en colecciones de forma an'aloga
 a los registros en tablas, pero con la diferencia de que, mientras los registros tienen una
 estructura inmutable (misma secuencia de campos), los documentos son totalmente variables y
 no tienen por qu'e guardar relaci'on entre s'i.
 
 Algunos de los ejemplos m'as famosos son MongoDB\footnote{\url{http://www.mongodb.org}} y CouchDB\footnote{\url{http://couchdb.apache.org/}}.
 
 \item Orientadas a columnas.
 Su funcionamiento es parecido al de las bases de datos relacionales, pero en lugar de almacenar registros
 utilizan columnas de datos. Su uso principal se centra en realizar agregaciones y consultas sobre
 grandes cantidades de datos.
 
 La base de datos Cassandra\footnote{\url{http://cassandra.apache.org}} podr'ia incluirse en esta secci'on.
 
 \item Clave-valor.
 Su modelo de datos fundamental es el de array asociativo (diccionarios), donde los datos se representan
 como pares clave-valor, de forma que cuando se necesita extraer un dato se realiza una
 b'usqueda por su clave.
 
 Un ejemplo de base de datos Clave-valor es Redis\footnote{\url{http://redis.io}}.
 
 \item En grafo.
 Estas bases de datos se basan en teor'ia de grafos, utilizando nodos, aristas y propiedades para
 representar y almacenar los datos. Esto quiere decir que cada elemento almacenado en la base
 de datos contiene un puntero directo a sus elementos adyacentes, por lo que pueden llegar a
 ser muy 'utiles para algunos proyectos espec'ificos como pueden ser redes sociales.
 
 En esta categor'ia se encontrar'ia, por ejemplo, Neo4J\footnote{\url{http://www.neo4j.org}}.
 
\end{itemize}

Despu'es de revisar las caracter'isticas de muchas de estas bases de datos y la acogida que ten'ian en la
comunidad, nos gustaron especialmente tres
de ellas: MongoDB, CouchDB y Redis. Sin embargo, como se coment'o al principio de esta secci'on, hay factores
externos adem'as de las caracter'isticas de cada una que debemos tener en cuenta. Debido a un software de terceros
que usaremos para la comunidad, nos vimos obligados a descartar CouchDB puesto que no era compatible con esta base de datos.
S'i lo es, en cambio, con MongoDB y Redis. Por otra parte, Redis almacena los datos en memoria RAM y, aunque
con el hardware que utilizamos en el momento de realizar este PFC no tendr'iamos ning'un problema, es posible
que en un futuro esto no sea as'i, por lo que tambi'en descartamos Redis en favor de MongoDB.

%mongodb

\begin{center}
\includegraphics[width=0.5\textwidth]{mongodb}
\end{center}

MongoDB es una base de datos orientada a documentos de c'odigo abierto que proporciona alto rendimiento,
alta disponibilidad y escalado autom'atico \cite{mongodbmanual}.

La siguiente imagen muestra de forma gr'afica la organizaci'on de los datos en MongoDB y c'omo se realizar'ia
una funci'on para insertar nuevos datos\cite{mongodbmanual}:

\begin{center}
\includegraphics[width=0.8\textwidth]{mongodb_insert}
\end{center}

Dentro de las bases de datos NoSQL, MongoDB es una de las que han empezado con m'as fuerza
y que se ha hecho bastante conocida. Adem'as, sus documentos usan una estructura en formato
JSON (aunque se almacenan en BSON), lo cual hace que la transferencia de datos entre el servidor
y la propia base de datos sea muy sencilla, puesto que Javascript posee soporte nativo para JSON.
Por este motivo, el uso com'un de Javascript y JSON, Node.js y MongoDB se han empezado a utilizar
conjuntamente en numerosos proyectos en los 'ultimos a'nos.

%mongoose

\begin{center}
\includegraphics[width=0.5\textwidth]{mongodb_mongoose}
\end{center}

Para simplificar la conexi'on entre Node.js y MongoDB se ha utilizado MongooseJS\footnote{\url{http://mongoosejs.com}}, un
Object Data Modeling (ODM) que envuelve al controlador nativo de conexi'on de Node.js.

\begin{verbatim}
var mongoose = require('mongoose');
mongoose.connect('mongodb://localhost/test');
\end{verbatim}

Mongoose proporciona un modelado riguroso de los datos mediante el uso de esquemas, reforzando la estructura
y comprobando la validez de los datos a la vez que se mantiene la flexibilidad que hace a MongoDB tan
potente. El modo de funcionamiento de Mongoose es el siguiente. Primero se define un esquema:

\begin{verbatim}
var userSchema = mongoose.Schema({
    name: String,
    age: { type: Number, min: 0}
})
\end{verbatim}

Luego se crea un modelo a partir del esquema definido anteriormente:

\begin{verbatim}
var SUser = mongoose.model('SUser', userSchema);
\end{verbatim}

Se instancia:

\begin{verbatim}
var Larry = new SUser({ name: 'Larry' }, age: 46);
\end{verbatim}

Y se guarda en la base de datos:

\begin{verbatim}
Larry.save(function (err) {if (err) console.log ('Error')});
\end{verbatim}

MongoDB crear'a una base de datos y una colecci'on bajo demanda en caso de que no existan ya. Adem'as, se pueden
asociar m'etodos a los esquemas y ejecutar consultas sobre los modelos definidos para obtener datos de la base
de datos con esta estructura. Como puede observarse, en general, Mongoose hace incluso m'as f'acil la conexi'on
entre Node.js y MongoDB.


\subsubsection{Configuraci'on del servidor}
\label{sub:configuracion_del_servidor}
%nginx
El proyecto \Nipponline{} est'a alojado en un servidor privado con el cual se pueden realizar demostraciones de las aplicaciones.
Para el correcto funcionamiento de dichas aplicaciones y de la comunidad web, se han realizado una serie de acciones que se explican 
a continuaci'on:
\paragraph{Servidor HTTP}


El servidor que se est'a utilizando para el proyecto tiene otras muchas aplicaciones web ejecut'andose cont'inuamente, por lo que
necesitamos hacer uso de un servidor HTTP (o servidor web) para redireccionar cada URL a la aplicaci'on que corresponda (que usan puertos
distintos entre s'i). El servidor HTTP elegido ha sido Nginx\footnote{\url{http://nginx.org}}, puesto que es bastante m'as liviano que Apache\footnote{\url{https://httpd.apache.org}} y cubre perfectamente nuestras necesidades.
La forma de configurar Nginx es la siguiente:

\begin{verbatim}
server {
        listen 80;

        server_name japanize.me app.japanize.me;

        location / {
                proxy_pass http://localhost:3300/;
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection 'upgrade';
                proxy_set_header Host $host;
                proxy_cache_bypass $http_upgrade;
        }
}
\end{verbatim}

As'i, siempre que se acceda al servidor a trav'es de la URL ``japanize.me'' o ``app.japanize.me'', Nginx redigir'a a nuestra aplicaci'on, la cual estar'a escuchando en el puerto 3300.
Lo mismo ocurre con la comunidad web, pero con otro puerto y otra URL (``community.japanize.me''), pues es una aplicaci'on diferente.

Por otra parte, un tema importante a la hora de configurar el servidor es qui'en debe servir qu'e contenido. Existe contenido est'atico, como pueden ser im'agenes, ficheros JS, HTML5 o CSS,
y tambi'en contenido din'amico, como los HTML generados en el servidor mediante templates (Handlebars, Jade). Node.js podr'ia encargarse de todo perfectamente, pero resulta que
Nginx es m'as eficiente que Node.js a la hora de servir contenido est'atico por lo que, sobretodo para el caso de las im'agenes, configuraremos nuestro servidor HTTP de esta manera:

\begin{verbatim}
        location /images {
                alias /var/node/Nipponline/public/images;
        }
\end{verbatim}

Con esta sencilla l'inea en el fichero de configuraci'on, Nginx servir'a el contenido de esta ruta siempre que se solicite.

\paragraph{Implementaci'on de sesiones}


Como se puede intuir en la secci'on anterior, nuestra aplicaci'on del proyecto y nuestra comunidad web son dos procesos ejecutados independientemente.
Nos encontramos, por tanto, con el problema de ``conectar'' ambas aplicaciones (el foro y el servidor de aplicaciones de \Nipponline{}) para que las
sesiones entre ambas sean compartidas, de foma que iniciar sesi'on en el foro sea equivalente a iniciar sesi'on en las otras aplicaciones y viceversa.
Para solucionar este problema hemos optado por reproducir el mecanismo de autenticaci'on y creaci'on de cookies que usa la comunidad web (software de terceros)
en nuestro servidor.

\paragraph{Comprobaciones}


En el servidor se almacenan datos estad'isticos sobre los resultados de los usuarios en las distintas aplicaciones. Estos datos son recopilados en el lado
del cliente y enviados al servidor para su posterior almacenamiento. Esto implica el riesgo de que alg'un usuario falsee un env'io de datos desde la aplicaci'on
(podr'ia ser modificado, por ejemplo, con la consola de desarrollo de los navegadores web), lo que har'ia que nuestro servidor almacenara datos err'oneos que
podr'ian tener una repercusi'on muy grande en la comunidad. Para evitar este problema el servidor realiza una comprobaci'on de los datos obtenidos para
verificar que no han sido falseados de ninguna forma.

\subsubsection{Comunicaci'on cliente-servidor}
\label{sub:comunicacion_cliente_servidor}
%socket.io

\Nipponline{} es un proyecto de software libre y c'odigo abierto, por lo que cualquiera puede unirse al proyecto y
colaborar con 'este desarrollando nuevas funcionalidades para el mismo.

Uno de los principales elementos del proyecto son las aplicaciones del lado del cliente enfocadas a aprender
japon'es, y de las cuales tambi'en queremos que nuestros futuros colaboradores puedan ser part'icipes, de forma que
puedan desarrollar libremente nuevas aplicaciones que diferentes a las ya existentes por su cuenta.

A fin de lograr este objetivo hemos trabajado (y seguimos trabajando) en ofrecer desde el servidor una API con
diferentes llamadas, para realizar diferentes tareas como obtener y enviar datos al servidor, que facilitar'an la
tarea a nuevos colaboradores y desarrolladores que quieran trabajar en sus propias aplicaciones, sin tener que
entretenerse en leer toda la documentaci'on e implementaci'on del lado del servidor del proyecto.

Para esta tarea hemos utilizado la tecnolog'ia Socket.IO\footnote{\url{http://socket.io/}}. Socket.IO es una 
biblioteca para Javascript orientada a eventos que permite una comunicaci'on bidireccional y en tiempo real 
entre clientes y el servidor. Como se ilustra en la siguiente figura, Socket.IO se compone de dos librer'ias, una se 
ejecuta en el lado del servidor con Node.js, mientras que la otra se encuentra en el lado del cliente.

\begin{center}
\includegraphics[width=0.7\textwidth]{socketio}
\end{center}

En el servidor se configuran los diferentes callback que deben invocarse como resultado de las llamadas Socket.IO
realizadas por el cliente, de forma que extraigan los datos enviados (si se enviaron datos), realicen las acciones
necesarias (extracci'on o almacenamiento en la base de datos, por ejemplo) y devuelvan una confirmaci'on al cliente
(con datos adicionales, si es necesario).

Desde el cliente basta con importar la biblioteca de Socket.IO del cliente y establecer una conexi'on con el servidor:

\begin{verbatim}
var socket = io.connect();
\end{verbatim}

Al realizar la conexi'on inicial, el servidor siempre env'ia una respuesta al cliente notific'andole si tiene una
sesi'on abierta o no con el servidor (True o False). Desde el cliente es posible capturar esta respuesta:

\begin{verbatim}
socket.on('acknowledge', function(data){
    console.log(data);
});
\end{verbatim}

En el c'odigo anterior simplemente se define una funci'on de callback que se ejecutar'a al recibir del servidor un
mensaje marcado como 'acknowledge'. El argumento data de la funci'on es donde se encontrar'an los datos devueltos
por el servidor (si se devuelven datos).

\subsubsection{Biblioteca de dibujo}
\label{sub:biblioteca_de_dibujo}
%createjs

Como ya hemos comentado anteriormente, nuestro lenguaje de elecci'on para la programaci'on en el
lado del cliente va a ser Javascript. 
Uno de los principales elementos de \Nipponline{} son las aplicaciones del cliente, que permiten a
los usuarios aprender y reforzar su conocimiento del idioma japon'es a trav'es de minijuegos. El
alto componente de gr'aficos y animaciones de estos minijuegos nos plantea un nuevo problema, ya
que no podemos limitarnos a usar simplemente Javascript. Debemos, adem'as, hacer uso de una
biblioteca o framework que nos ayude en la tarea de programar los juegos para el cliente en
Javascript.

Nuestra elecci'on para esta tarea es CreateJS\footnote{\url{http://www.createjs.com/}}, una suite compuesta de 4 
sub-frameworks que a'naden funcionalidad a Javascript, facilitando el desarrollo de aplicaciones
gr'aficas e interactivas mediante el dibujado en elementos canvas (lienzo) de HTML.

\begin{center}
\includegraphics[width=0.8\textwidth]{create_suite}
\end{center}

Los 4 sub-frameworks de CreateJS mencionados son:

\begin{itemize}
\item \textbf{EaselJS.} Probablemente el componente m'as importante de la suite, ya que es el que incluye
toda la funcionalidad necesaria para dibujar en el canvas, as'i como crear y manejar animaciones
personalizadas.
\item \textbf{TweenJS.} Tween (o Inbetweening) consiste en animar un elemento de forma que una (o varias)
de sus propiedades evolucionen de forma m'as o menos suave en el tiempo. Esto permite realizar
animaciones de car'acter m'as general de forma autom'atica (sin usar c'odigo espec'ifico de 
control en el bucle de animaci'on), como puede ser desplazar o escalar una imagen en el tiempo.
\item \textbf{SoundJS.} Este componente es el que, como su nombre indica, permite el uso de sonido en las
aplicaciones.
\item \textbf{PreloadJS.} Este componente permite realizar la carga de recursos (im'agenes o sonidos) desde
el servidor de forma automatizada y as'incrona, proporcionando la posibilidad de definir callbacks
para su coordinaci'on.
\end{itemize}

Los principales motivos de decidirnos por el uso de la suite de CreateJS se enumeran a continuaci'on:

\begin{itemize}
\item \textbf{Estilo de programaci'on.} Despu'es de examinar la API y las demos que ofrecidas por la 
comunidad de CreateJS comprobamos que el estilo de uso de las funciones para dibujado y animaci'on
es bastante similar al que est'abamos acostumbrados a utilizar en otros proyectos en los que 
hemos trabajado con gr'aficos.
\item \textbf{Licencia.} CreateJS est'a sujeto a una licencia MIT, por lo que se adapta perfectamente a 
nuestras necesidades de uso exclusivo de software libre. Adem'as, si fuese necesario, la licencia
MIT nos permite realizar modificaciones sin necesidad de aplicar nuevamente una licencia MIT al 
resultado.
\end{itemize}

A continuaci'on se mencionan varias alternativas para dibujado en el lado del cliente que se han
considerado, pero que finalmente no hemos usado:

\begin{itemize}
\item \textbf{gameQuery\footnote{\url{http://gamequeryjs.com/}}.} Extensi'on para jQuery que facilita la realizaci'on 
de animaciones y juegos en general. Su uso fue descartado debido a que se basaba en la manipulaci'on
del DOM, en lugar de usar elementos canvas de HTML (dibujando sobre estos). 
La justificaci'on de esta decisi'on est'a en el hecho de que nuestra poca experiencia en
desarrollo web nos hac'ia reticentes a jugar con el DOM. Por otra parte, usando una biblioteca
de dibujado en el canvas pod'iamos despreocuparnos de  la manipulaci'on del DOM y centrarnos
'unicamente en lo que ocurre dentro del canvas.
Para finalizar, tambi'en hemos tenido en cuenta que el dibujado sobre el canvas es ligeramente
m'as eficiente en la mayor'ia de los casos que manipular el DOM, adem'as de ofrecer una mayor
compatibilidad entre navegadores web.

\begin{center}
\includegraphics[width=0.4\textwidth]{gamequery}
\end{center}

\item \textbf{LimeJS\footnote{\url{http://www.limejs.com/}}.} Otra biblioteca para gr'aficos con Javascript con funcionalidad similar a la 
ofrecida por CreateJS. Sin embargo, LimeJS no proporciona una utilidad de precarga de recursos 
(a diferencia de CreateJS, que proporciona PreloadJS), por lo que deber'iamos implementar algo
similar por nuestra cuenta o buscar alguna alternativa. Adem'as, LimeJS requiere tener Python
instalado para su uso, lo que impone unas restricciones adicionales a los desarrolladores.
\item \textbf{MelonJS\footnote{\url{http://melonjs.org/}}.} Una alternativa m'as que, al igual que LimeJS, ofrece una funcionalidad muy similar
a la de CreateJS. Del mismo modo, el motivo por el cual esta biblioteca no ha sido usada es la 
ausencia de un m'odulo para el precargado de recursos que CreateJS s'i ofrece.
\item \textbf{GameMaker\footnote{\url{https://www.yoyogames.com/studio}}.} Una biblioteca potente con multitud de funcionalidades. Desafortunadamente, su
licencia es de pago y, por tanto, incompatible con nuestro proyecto (que pretende ser un proyecto
de software libre que utiliza 'unicamente elementos de la misma naturaleza), motivo por el cual 
es desechada.
\end{itemize}

\subsubsection{Internacionalizaci'on}
\label{sub:internacionalizacion}
%i18n

Dado que queremos abrir el uso de nuestras aplicaciones a la mayor cantidad de p'ublico posible necesitamos
asegurarnos de su traducci'on a varios idiomas. A la hora de traducir una aplicaci'on hay dos elementos a tener en
cuenta: la internacionalizaci'on (i18n) y la localizaci'on (l10n) de la aplicaci'on.

\begin{itemize}
\item \textbf{Internacionalizaci'on.} Consiste en el dise'no de software (en nuestro caso las aplicaciones) de forma
que sea posible su traducci'on a diferentes idiomas sin que ello conlleve realizar modificaciones en el
c'odigo/dise'no de este.
\item \textbf{Localizaci'on.} Se trata de la traducci'on de la aplicaci'on a un idioma concreto en s'i. Se sirve de
los mecanismos proporcionados por la internacionalizaci'on para mostrar la traducci'on.
\end{itemize}

Podemos deducir f'acilmente que la fase de internacionalizaci'on es la m'as compleja desde el punto de visto del
dise'no y desarrollo de nuestras aplicaciones. Debemos plantearnos cuestiones tales como la forma en que la
aplicaci'on detecta las preferencias de idioma de los usuarios, c'omo almacenar en el servidor las traducciones
correspondientes, con qu'e formato, etc.

Nosotros hemos decidido hacer uso de la biblioteca i18next\footnote{\url{http://i18next.com/}}, compatible con 
Javascript y Node.js. Esta biblioteca se basa en la existencia de un directorio de 'locales' en el servidor, donde 
se almacenan las traducciones de diferentes textos de las aplicaciones en formato JSON. Al iniciar el servidor, se 
inicializa i18next, indic'andole donde se encuentra el directorio de 'locales':

\begin{verbatim}
i18n.init({
    resGetPath: 'public/locales/__lng__/__ns__.json'
});
\end{verbatim}

A partir de este momento, las peticiones de clientes de traducciones har'an que el servidor env'ie el archivo JSON
correspondiente al idioma indicado por el cliente (existe un directorio por defecto en ingl'es que se usa cuando el
idioma del cliente no est'a disponible).

El Javascript del cliente, por su parte,  debe importar la biblioteca i18next e inicializar la variable i18n para
recibir la traducci'on del servidor:

\begin{verbatim}
i18n.init({ useCookie: false }, callback);
\end{verbatim}

Como se puede ver, es posible asignar una funci'on de callback que es llamada en cuanto se recibe el JSON del
servidor y cuyo cometido suele ser realizar la traducci'on de la aplicaci'on del cliente.
Por defecto, i18next toma el idioma favorito del navegador para realizar la petici'on del archivo JSON con las
traducciones al servidor, aunque es posible indicar un idioma concreto.

Una vez recibido el JSON con las traducciones, acceder a estas solo requiere conocer la etiqueta de la traducci'on
concreta que se quiere obtener:

\begin{verbatim}
translation = i18n.t("textField1");
\end{verbatim}

\subsubsection{Gamificaci'on}
\label{sub:gamificacion}
%mozillaBadges

Como ya hemos comentado, con \Nipponline{} no queremos limitarnos solo al desarrollo de un conjunto de aplicaciones para
aprender japon'es, sino que adem'as queremos crear una comunidad donde diferentes usuarios puedan interactuar entre
s'i.

El primer paso en la creaci'on de la comunidad pasa por el uso de unos foros que en nuestro caso nos proporciona un
software de terceros. 
Adicionalmente, queremos a'nadir a \Nipponline{} una Gaming Layer: los usuarios de \Nipponline{} tendr'an niveles, objetos
o logros asociados a su cuenta. Todos estos elementos ser'an desbloqueables por medio de la participaci'on en la
comunidad (participando en los foros, usando las aplicaciones y/o obteniendo ciertas puntuaciones en estas).

Para implementar, en parte, esta funcionalidad nos hemos decantado por el uso de las OpenBadges de 
Mozilla\footnote{\url{http://www.openbadges.org/}}.

\begin{center}
\includegraphics[width=0.5\textwidth]{mozilla_badges}
\end{center}

OpenBadges permite a sitios web (como \Nipponline{}) definir un conjunto de badges (medallas o insignias) a ser 
obtenidas por los usuarios de dichos sitios web al completar ciertas tareas. Estas insignias se almacenan en la
Mozilla Backpack del usuario, que puede a partir de ese momento mostrar sus nuevas insignias en cualquier sitio web
que implemente la capacidad de mostrar OpenBadges. 

En la siguiente figura se ilustra la infraestructura\cite{mozillawiki}  y funcionamiento abstracto de 
OpenBadges.

\begin{center}
\includegraphics[width=1.0\textwidth]{badges_infrastructure}
\end{center}

OpenBadges es software libre, al igual que \Nipponline{}, con las ventajas que esto conlleva. Cualquiera puede crear y
otorgar su propio conjunto de insignias a usuarios por realizar tareas.
Adem'as, los usuarios pueden mostrar, si as'i lo desean, las insignias obtenidas en \Nipponline{} en cualquier lugar en
el que esto sea posible (existen plugins para Wordpress o Twitter que a'naden esta  funcionalidad). Esta es la raz'on
principal de hacer uso de OpenBadges en \Nipponline{} en lugar de crear nuestro propio conjunto de insignias privado
(caso en el que las insignias obtenidas no habr'ian abandonado el 'ambito de \Nipponline{}, limitando la difusi'on de la
comunidad).

Una desventaja del uso de OpenBadges es el hecho de que es necesario que el usuario posea una Mozilla Backpack donde
almacenar las insignias, aunque si no posee una puede optar por no obtener la insignia sin que ello supongo problema
alguno. 

\subsubsection{Control de versiones}
\label{sub:control_de_versiones}
%Git
%Github

Dada la naturaleza colaborativa del proyecto \Nipponline{} (no solo hemos trabajado conjuntamente en 'el dos personas, 
sino que al ser software libre es posible que en el futuro aparezcan nuevos colaboradores para trabajar en el 
proyecto) necesitamos utilizar alg'un software de control de versiones que permita la colaboraci'on fluida y de forma
sencilla de diferentes personas en el desarrollo del proyecto.

Obviamente, es imposible trabajar en el proyecto de forma local, dado que desde un primer momento hemos sido personas
los que hemos estado trabajando en el desarrollo de \Nipponline{}. Adem'as, conforme un proyecto va creciendo se hace
cada vez m'as dif'icil mantener de forma local el historial de cambios del mismo y su mantenimiento se vuelve muy
tedioso.

As'i pues, queda claro que debemos usar alguna herramienta para el control de versiones. En este punto debemos
decidir si vamos a emplear un sistema de control de versiones centralizado o distribuido, as'i como la herramienta
concreta a usar.

A continuaci'on se comentan los dos tipos de sistemas de control de versiones\cite{versioncontrol} considerados y el
motivo de elegir uno sobre el otro.

\begin{itemize}
\item \textbf{Control de versiones centralizado:} En este esquema existe un 'unico repositorio central y todos los
cambios realizados en el proyecto por parte de los colaboradores deben ser enviados a este repositorio. Obviamente,
para poder realizar cambios en el proyecto es necesario que los colaboradores se descarguen los 'ultimos cambios
realizados por otros usuarios y que pueden no estar actualizados en su copia local del proyecto.
Algunas conocidas herramientas de control de versiones centralizado son SVN y CVS.

\begin{center}
\includegraphics[width=0.7\textwidth]{version_centralized}
\end{center}

\item \textbf{Control de versiones distribuido:} En este esquema no existe un 'unico repositorio, sino que cada
colaborador del proyecto obtiene su propio repositorio sobre el que puede trabajar de forma independiente sin
necesidad de actualizarlo con los cambios que realicen otros usuarios. Cabe destacar que el hecho de que no exista
un 'unico repositorio no implica necesariamente que no haya un repositorio maestro en el que converjan los cambios
realizados por todos los colaboradores.
Entre las herramientas de control de versiones distribuido se encuentran Git, Mercurial y Bazaar.

\begin{center}
\includegraphics[width=0.7\textwidth]{version_distributed}
\end{center}

\end{itemize}

Vemos pues que frente al control de versiones centralizado, un esquema distribuido aporta pr'acticamente solo mejoras
y una mayor flexibilidad durante el desarrollo del proyecto, motivo por el cual nos decidimos claramente por el uso
de un sistema de control de versiones distribuido.

\textbf{Git}

Entre las diferentes alternativas disponibles para control de versiones distribuido nos hemos decantado por Git.
A continuaci'on se resumen algunas de las caracter'isticas de Git\footnote{\url{http://git-scm.com/about/}}.

\begin{itemize}
\item \textbf{Licencia GPL.} Git es software libre y de c'odigo abierto, por lo que cualquiera puede modificarlo de
la forma que considere oportuna.
\item \textbf{Rapidez.} Git es r'apido en sistemas Linux, incluso m'as que otras herramientas de control de versiones
distribuidas como Mercurial. El hecho de ser distribuido le da una gran ventaja en velocidad sobre otras herramientas
de control de versiones centralizadas, ya que todas las operaciones se hacen de forma local, mientras que en los
sistemas centralizados es necesario comunicarse con el servidor donde se encuentra el repositorio para cada
operaci'on.
\item \textbf{Modelo de ramas.} Una de las caracter'isticas m'as reconocibles de Git es la posibilidad de trabajar
con ramas, copias del repositorio original sobre las que se puede trabajar de forma independiente para probar cosas
nuevas o arriesgadas cuyo impacto en el proyecto es desconocido o se quiere medir, sin que estos cambios afecten a
la rama principal del proyecto. Una vez finalizado el trabajo sobre la rama es posible fusionarla con la rama
principal o descartar los cambios realizados en funci'on del resultado de estos.
\item \textbf{'indice.} Todos los proyectos usando Git usan un 'indice o staging area que permite configurar los
commit o cambios del repositorio de forma flexible. Es posible, por ejemplo, actualizar en el repositorio con un
commit solo algunos ficheros de todos los modificados o diferentes cambios consecutivos sobre un mismo fichero en
diferentes commits.

\begin{center}
\includegraphics[width=0.6\textwidth]{index}
\end{center}

\item \textbf{Seguridad e integridad de los datos.} Git utiliza sumas de verificaci'on (checksums) en todos los
ficheros y commits de un proyecto, lo que permite tener un control total de los cambios del mismo, impidiendo que
cambios externos el sistema de control de versiones pasen inadvertidos a este.
\item \textbf{Apoyo.} Git es una de las herramientas de control de versiones con mayor apoyo en forma de n'umero de
plataformas de hosting (GitHub, Google Code) que soportan su uso, frente a otras como Mercurial que cuentan con un
apoyo menor.
\end{itemize}

\textbf{GitHub}

Finalmente, una vez escogido nuestro sistema de control de versiones nos queda escoger una plataforma a trav'es de la
cual podamos distribuir nuestro proyecto y que soporte el uso de Git. Hemos elegido para ello GitHub, por ser una
comunidad muy activa de desarrolladores, que alberga numerosos proyectos de distinta envergadura.

GitHub permite tener un n'umero ilimitado de repositorios p'ublicos y requiere una suscripci'on de pago para poder
crear repositorios privados. No obstante, dado que nuestro proyecto es de c'odigo libre, vamos a crear un repositorio
p'ublico y nos supone ning'un obst'aculo la limitaci'on en cuanto a repositorios privados.

Otra caracter'istica interesante de GitHub es el hecho de permitir un n'umero ilimitado de colaboradores en los
repositorios, algo que otras plataformas no permiten. Esto permite que al proyecto puedan adherirse tantos
colaboradores como haga falta si en el futuro este ganara suficiente popularidad.

%%%%%%%%%%%%%%

\subsection{Comunidad}
\label{sec:comunidad}
Una de las partes m'as interesantes de una plataforma como la que pretende ser \Nipponline{} es la comunidad web debido
a muchos motivos. Para empezar, el aprendizaje de un idioma es una tarea lenta que puede desmotivar a menudo en caso
de que no se aprecien avances, con lo cual estudiar en solitario puede no ser una buena idea. Por el contrario, hacer
uso de una comunidad online donde todos los usuarios est'an aprendiendo el mismo idioma supone una motivaci'on extra
y una ayuda a la hora de resolver dudas sobre el idioma. Si a 'esto le a'nadimos un toque de competitividad entre dichos
usuarios, probablemente los mismos se esfuercen y motiven a'un m'as.

Otro motivo diferente es que \Nipponline{} pretende contener toda la informaci'on posible acerca del idioma y la cultura
de Jap'on, pero hacer esto entre únicamente desarrolladores es una tarea imposible. Es mucho m'as pr'actico que sean
los propios usuarios los que creen contenido y compartan noticias e historias sobre la actualidad y la cultura del pa'is,
por lo que tener una comunidad web se convierte en un requisito indispensable para realizar todo esto.

Cuando hablamos de ``comunidad'' nos estamos refiriendo a un conjunto de herramientas que hace posible que los usuarios
socialicen entre s'i e intercambien experiencias, como pueden ser foros, chats, blogs, perfiles de usuario personalizables
y otras herramientas relacionadas. Como puede suponerse, ya existen numerosas herramientas para realizar estas funciones,
aunque la mayor'ia de ellas usan tecnolog'ias que no nos interesan demasiado o simplemente son servicios de pago.
Al principio del proyecto se contempl'o la posibilidad de desarrollar estas herramientas tambi'en desde cero usando
Javascript y Node.js, puesto que as'i podr'iamos crear algo adaptado totalmente a nuestras necesidades. Sin embargo, finalmente
encontramos una plataforma que ofrec'ia exactamente lo que busc'abamos.

\begin{center}
\includegraphics[width=0.1\textwidth]{nodebb_icon}
\includegraphics[width=0.3\textwidth]{nodebb_logo}
\end{center}

NodeBB\footnote{\url{https://nodebb.org/}} es una plataforma de discusi'on de nueva generaci'on que utiliza web sockets para realizar interacciones
instant'aneas y tener notificaciones en tiempo real. NodeBB est'a desarrollado con Node.js sobre una base de datos
Redis (aunque recientemente tambi'en dan soporte a MongoDB), y adem'as es un proyecto de c'odigo abierto que est'a
en continuo crecimiento gracias a su inmensa comunidad de seguidores. Posee todas las caracter'isticas que busc'abamos,
como foros, chats y perfiles de usuario, y adem'as usa las mismas tecnolog'ias que \Nipponline{}.

\begin{center}
\includegraphics[width=1.0\textwidth]{comunidad}
\end{center}

Por lo tanto, se ha elegido NodeBB como base para crear una comunidad web donde se enlazar'an las aplicaciones del proyecto
y las lecciones te'oricas del idioma. Al ser un proyecto de c'odigo abierto y estar desarrolado con Node.js, podremos modificarlo
seg'un nuestras preferencias e incluso aportar mejoras al propio proyecto de NodeBB en caso de que agreguemos alguna funcionalidad
extra que sea 'util para otros usuarios.

%%%%%%%%%%%%%%

\subsection{Aplicaciones}
\label{sec:aplicaciones}

Las aplicaciones desarrolladas comparten una serie de elementos y estructura. Los principales 
elementos comunes se listan a continuaci'on:

\begin{itemize}
\item \textbf{Comunicaci'on con el servidor.} La comunicaci'on con el servidor se realiza con la ayuda de la interfaz 
Socket.IO. El tipo de peticiones enviadas al servidor var'ia en funci'on de la aplicaci'on concreta (por ejemplo, el
minijuego-1 pide al servidor que le env'ie una lista con las diferentes s'ilabas del lenguaje japon'es, mientras que
el minijuego-2 pide una lista de palabras).
Tambi'en es por medio de Socket.IO que las aplicaciones son capaces de detectar si el usuario tiene una sesi'on 
iniciada, en cuyo caso sus estad'isticas son enviadas y registradas en el servidor.
\item \textbf{Estructura HTML.} Todas las aplicaciones comparten una misma estructura HTML cuyo punto central es un elemento
canvas sobre el que se realiza el dibujado necesario, as'i como una pantalla de carga (creada con elementos div y 
CSS) que solo es visible mientras se cargan los recursos de la aplicaci'on concreta.
Al margen de estos elementos, cada aplicaci'on incluye una serie de elementos propios como pueden ser campos de texto
o botones, en funci'on de las necesidades de la misma.
\item \textbf{Precarga de recursos.} Con la ayuda de la biblioteca PreloadJS ofrecida por CreateJS es posible declarar una
lista personalizada con todos los recursos necesarios para la aplicaci'on (im'agenes o audio) y enviar una petici'on
al servidor para que nos devuelva estos recursos.
PreloadJS ofrece adem'as funciones callback que se invocan durante el proceso de precarga cada vez que este avanza,
lo que nos permite, haciendo uso de jQuery, actualizar la pantalla de carga y borrarla una vez se ha completado la
carga.
Para realizar la carga debemos declarar primero una lista de objetos JSON que contenga todos los recursos que 
queremos que el servidor nos env'ie.

\begin{verbatim}
manifest = [];
manifest.push({src:"images/app2/bg.png", id:"bg", 
                 imageType:"background"});
manifest.push({src:"images/app2/power1.gif", id:"power1"});
\end{verbatim}

el atributo ``src'' es obligatorio e indica al servidor la ruta, dentro del directorio public, que ocupa el archivo
a traer en el servidor, mientras que el atributo ``id'' se utiliza para identificar el recurso en concreto. El atributo
``imageType'' se utiliza para tratar de forma diferente a las im'agenes seg'un sean spritesheets, backgrounds (fondos)
o im'agenes normales.

Una vez declarado el manifiesto debemos cargarlo para que PreloadJS se encargue de hacer las peticiones 
correspondientes al servidor. Adicionalmente definimos varias funciones de callback:

\begin{verbatim}
queue = new createjs.LoadQueue();
queue.addEventListener("progress", handleProgress);
queue.addEventListener("complete", handleComplete);
queue.addEventListener("fileload", handleFileLoad);
queue.loadManifest(manifest);
\end{verbatim}

El evento 'progress' tiene lugar cada cierto porcentaje del proceso de carga, y se utiliza el callback asociado a 
este evento, la funci'on handleProgress, para modificar y hacer avanzar la barra de progreso en la pantalla de carga
de la aplicaci'on.
El evento ``fileload'' ocurre cada vez que se termina de cargar un archivo del manifiesto y su callback se encarga de
tratar cada uno de los archivos de la forma indicada. As'i, por ejemplo, una imagen de tipo spritesheet es procesada 
para crear un objeto de animaci'on Sprite de EaselJS.
El evento ``complete'' solo tiene lugar una vez, al terminar de cargar todos los recursos. Su callback, handleComplete,
se encarga de ocultar la pantalla de carga y dejar la aplicaci'on en su estado inicial.
\item \textbf{Internacionalizaci'on.} Todas las aplicaciones hacen uso de la biblioteca i18next, para internacionalizaci'on
con Javascript. El uso de la biblioteca es simple, basta con hacer una llamada de inicializaci'on al inicio de la
aplicaci'on para que el servidor nos env'ie el archivo de localizaci'on correspondiente. Una vez hemos recibido el
resultado (es posible definir una funci'on de callback para cuando se reciba la respuesta del servidor), tenemos 
acceso a las traducciones de los diferentes texto de la aplicaci'on a trav'es de un objeto JSON.
\item \textbf{Bucle de animaci'on.} Las aplicaciones implementan una funci'on update() que gestiona todo el bucle de 
animaci'on y que es llamada FPS veces por segundo, donde FPS (frames per second) suele ser 30 y se refiere al n'umero
de refrescos de pantalla por segundo.
La funci'on update se puede descomponer en 3 fases, ilustradas a continuaci'on:

\begin{center}
\includegraphics[width=0.4\textwidth]{draw2d}
\end{center}

\begin{enumerate}
\item \textbf{Cambio de estado.} En esta fase se llevan a cabo todas las tareas relativas a la l'ogica de aplicaci'on,
pasando de un estado de la aplicaci'on dado (el actual) al siguiente en funci'on del mismo. As'i, se realizan tareas
como cambiar la posici'on de elementos en la pantalla seg'un la velocidad que lleven o disminuir la cantidad de 
energ'ia del jugador si se detecta una colisi'on del mismo con un elemento da'nino.
\item \textbf{Dibujado.} Una vez obtenido el nuevo estado de la aplicaci'on debemos dibujarlo en el lienzo para sustituir
al antiguo, de forma que el usuario aprecie en pantalla los cambios que van sucediendo en la aplicaci'on.
\item \textbf{Cambio de buffer.} Generalmente se utiliza una t'ecnica de doble buffer para dibujar en pantalla. Esta
t'ecnica consiste en realizar la fase 2 (dibujado) sobre un buffer, en lugar de sobre la pantalla directamente, lo 
cual podr'ia ocasionar un efecto de parpadeo. Una vez se ha dibujado sobre el buffer oculto, se sustituyen los 
contenidos de la pantalla por los del buffer.
En la siguiente figura se ilustra el funcionamiento del cambio de buffer.


\centerline{\includegraphics[width=1.1\textwidth]{double_buffer}}

En nuestras aplicaciones, no obstante, solo diferenciamos 2 fases, ya que CreateJS abstrae las fases 2 y 3 en una
'unica funci'on de actualizaci'on del canvas.
\end{enumerate}
\end{itemize}

\subsubsection{Syllables}
\label{sub:syllables}

El objetivo de esta aplicaci'on es el de introducir al usuario al lenguaje japon'es por medio de la pr'actica y
aprendizaje de los diferentes silabarios de los que est'a compuesto el lenguaje.

\begin{center}
\includegraphics[width=0.8\textwidth]{syllables_capt}
\end{center}

\textbf{Interfaz y funcionamiento}

En esta aplicaci'on se le presenta al usuario un lienzo sobre el que se dibujan s'ilabas japonesas (denominadas kana).
El objetivo del usuario es el de escribir en el campo de texto que se le proporciona la correspondiente romanizaci'on
(escritura en alfabeto latino) de las s'ilabas mostradas en pantalla.

La interfaz incluye un bot'on para pasar a la siguiente s'ilaba (contando la s'ilaba actual como fallo) en caso de 
que el usuario sea incapaz de reconocer la s'ilaba en pantalla, as'i como una lista desplegable que le permite elegir
a qu'e silabario pertenecer'an las s'ilabas mostradas en el futuro.

La aplicaci'on mantiene un recuento de las estad'isticas del usuario en forma del n'umero de s'ilabas consecutivas
que es capaz de acertar, as'i como la cantidad de veces que ha acertado  o fallado una cierta s'ilaba y el tiempo
medio empleado en cada cierto. El servidor recibe con cierta regularidad actualizaciones de estas estad'isticas
conforme el usuario utiliza la aplicaci'on a fin de mantenerlas actualizadas en la base de datos.

\textbf{Implementaci'on}

\begin{itemize}
\item \textbf{Petici'on al servidor.} La aplicaci'on comienza haciendo una petici'on al servidor del conjunto de todas las 
s'ilabas por medio de la API con Socket.IO:

\begin{verbatim}
socket.emit('getsyllables', 0, function (data) {
    kana = data;
});
\end{verbatim}

Tambi'en se define una funci'on de callback que se ejecuta en cuanto se obtiene la respuesta del servidor para asignar
el conjunto de s'ilabas obtenido a una variable local de la aplicaci'on.
\item \textbf{Interacci'on con el usuario.} El HTML de la aplicaci'on incluye un campo de texto en el que el usuario puede
escribir la romanizaci'on de las diferentes s'ilabas que aparecen en pantalla. Cambios en la entrada del campo de
texto se monitorizan a fin de comprobar si el usuario ha escrito la s'ilaba correctamente.
Tambi'en se han asociado funciones de respuesta a la pulsaci'on del bot'on para pasar de s'ilaba (se escoge una nueva
s'ilaba al azar para sustituir a la actual) y al cambio de opci'on en el men'u desplegable (se restringe el conjunto
de s'ilabas que pueden aparecer en pantalla en funci'on de la opci'on seleccionada).
\item \textbf{Actualizaci'on de estad'isticas.} Como ya hemos comentado, cada cierto tiempo se env'ia al servidor una 
actualizaci'on con las 'ultimas estad'isticas del usuario. Para ello vamos a utilizar la API con Socket.IO para 
comunicarnos con el servidor, como hicimos para obtener el conjunto de s'ilabas al inicio de la aplicaci'on.

\begin{verbatim}
socket.emit('game1:stats', [stats, streak], function (){
    // Respuesta del servidor
});
\end{verbatim}

En este caso vamos a enviar informaci'on al servidor, para lo cual usamos el segundo argumento de socket.emit, donde
depositamos las estad'isticas del usuario en esta aplicaci'on.
Obviamente, no es posible enviarle cualquier cosa al servidor, ya que este realiza las comprobaciones adecuadas al
recibir los datos para validarlos y comprobar que se ajustan al formato espec'ifico y que son realistas.
\end{itemize}

\subsubsection{Words}
\label{sub:words}

Esta aplicaci'on tiene como objetivo reforzar y profundizar en la pr'actica del usuario con los silabarios japoneses,
para lo cual propone al usuario escribir la romanizaci'on correspondiente a las palabras que aparecen en pantalla
(escritas con sus correspondientes kana).

\begin{center}
\includegraphics[width=0.8\textwidth]{okami_capt}
\end{center}

\textbf{Interfaz y funcionamiento}

En esta aplicaci'on el usuario est'a representado por un zorro que se desplaza por un campo. Desde la parte superior
de la pantalla aparecen palabras en japon'es cuya romanizaci'on debe escribir el usuario, de modo que desaparezcan
antes de que entren en contacto con su avatar (el zorro), lo cual provocar'ia que perdiera puntos de vitalidad (PV
de ahora en adelante).

La cantidad actual de PV del usuario se representa con una barra de color naranja en la parte superior derecha de la
pantalla. Una vez los PV alcanzan el valor de 0, se considera que el usuario ha fracasado y debe comenzar de nuevo.

La barra de la parte superior izquierda de la pantalla representa la cantidad actual de energ'ia (EN de ahora en 
adelante) del usuario. Es posible aumentar la cantidad de EN escribiendo correctamente la romanizaci'on de las 
palabras que aparecen en pantalla.
En la parte inferior derecha de la pantalla aparecen varios iconos que representan diferentes habilidades que puede
activar el usuario para facilitarle la tarea. Para poder activar estas habilidades el usuario debe tener una cantidad
concreta de EN disponible.

Por 'ultimo, la aplicaci'on mantiene un recuento de las estad'isticas del usuario en forma del n'umero de palabras
que ha sido capaz de escribir correctamente sin fracasar. Estas estad'isticas son pedidas al servidor al inicio y se
van enviando actualizaciones de estas con el paso del tiempo para mantenerlas actualizadas en el servidor.

\textbf{Implementaci'on}

\begin{itemize}
\item \textbf{Petici'on al servidor.} En primer lugar la aplicaci'on hace una llamada a la API proporcionada por el servidor
por medio de Socket.IO para obtener un conjunto aleatorio de 50 palabras:

\begin{verbatim}
socket.emit('getwords', 0, function (data) {
    wordSet = data;
});
\end{verbatim}

como se puede comprobar, se define una funci'on de callback que se ejecuta en cuanto se obtiene la respuesta del
servidor para asignar el conjunto de palabras obtenido a una variable local de la aplicaci'on.
\item \textbf{Interacci'on con el usuario.} El HTML de la aplicaci'on incluye un campo de texto en el que el usuario puede 
escribir la romanizaci'on de las diferentes palabras que aparecen en pantalla. Cambios en la entrada del campo de 
texto se monitorizan a fin de comprobar si, efectivamente, el usuario escribe correctamente la romanizaci'on de las
palabras.
As'i pues, se comprueba si el campo de texto contiene la romanizaci'on de la primera s'ilaba de alguna de las
palabras en pantalla, en cuyo caso se crea un proyectil dirigido a impactar con dicha palabra para eliminarla.
\item \textbf{Bucle de animaci'on.} Como vimos en apartados anteriores, la aplicaci'on se compone de un bucle de animaci'on 
que se encarga de 3 tareas: actualizar el estado de la aplicaci'on, dibujar el nuevo estado y refrescar la pantalla.
En este apartado nos vamos a centrar en la fase de actualizaci'on del estado de la aplicaci'on.

Las siguientes tareas se realizan en cada iteraci'on del bucle de animaci'on para actualizar el estado de la 
aplicaci'on:

\begin{enumerate}
\item \textbf{Desplazar el fondo.} Dado que el avatar del usuario en la aplicaci'on (el zorro) va avanzando por el campo, es
necesario ir moviendo el fondo que representa el campo para reforzar la impresi'on de movimiento en la aplicaci'on.
Para ello basta con que en el nuevo estado la posici'on del fondo este ligeramente desplazada hacia abajo con
respecto a su posici'on en el estado anterior.
\item \textbf{Actualizar palabras.} En cada nuevo estado es necesario actualizar la posici'on de todas las palabras
actualmente en pantalla de acuerdo a la velocidad horizontal y vertical que posean.
Adem'as, es necesario comprobar si las palabras han llegado al final de la pantalla, en cuyo caso son destruidas y
se le resta una cantidad de PV predeterminada al usuario.
Finalmente, tambi'en forma parte de esta tarea el crear nuevas palabras (a partir del conjunto de palabras tra'ido
del servidor) en la parte superior de la pantalla cada cierto tiempo.
\item \textbf{Actualizar proyectiles.} Al igual que ocurre con las palabras, tambi'en es necesario actualizar la posici'on de
los proyectiles actualmente en pantalla en funci'on de sus velocidades.
Tambi'en se comprueba si el proyectil ha hecho impacto con su objetivo (la distancia entre la posici'on del proyectil
y la posici'on de la palabra objetivo es menor que una cantidad dada), en cuyo caso se procede a eliminar una s'ilaba
del contenido de la palabra, disminuyendo su tama'no. Si la s'ilaba eliminada es la 'ultima, la palabra desaparece
por completo y deja de ser una amenaza para el usuario.
\item \textbf{Refrescar conjunto de palabras.} Cada cierto n'umero de palabras creadas se hace una nueva petici'on al servidor
v'ia Socket.IO para que nos devuelva un nuevo conjunto de palabras diferente que se empezar'a a usar tan pronto como
este disponible, a fin de dar variedad a la aplicaci'on y no usar siempre el mismo conjunto de palabras.
\end{enumerate}
\end{itemize}

\subsubsection{Pictionary}
\label{sub:pictionary}

Esta aplicaci'on tiene por objetivo permitir al usuario aprender vocabulario de forma entretenida. Un pictionary de este estilo
consiste en adivinar una palabra que otro usuario ha dibujado, de forma que se asocie el significado de una palabra con una imagen
que, por lo general, ser'a un dibujo divertido y f'acil de recordar. 

\begin{center}
\includegraphics[width=0.8\textwidth]{pictionary_capt}
\end{center}

\textbf{Interfaz y funcionamiento}

Esta aplicaci'on es multijugador, de forma que se necesitar'an al menos dos usuarios para que funcione. Los usuarios entran en la sala
y uno de ellos elige el turno de dibujo presionando un bot'on para ello. En este momento, al usuario que entra en el turno de dibujo
se le proporcionar'a una palabra aleatoria en japon'es que tendr'a que representar en un lienzo de dibujo. Podr'a cambiar el color
del trazo como desee y deber'a dibujar la palabra en un margen de tiempo l'imite. Mientras tanto, el resto de usuarios hacen uso
de un chat para poder escribir las palabras que ellos crean que coinciden con el dibujo que est'an viendo en tiempo real. En caso de
que se acierte la palabra en cuesti'on dentro del margen de tiempo l'imite, tanto el usuario que dibuja como el que acierte la
palabra recibir'an un bonus de puntos y el turno de dibujo se acabar'a. En este momento, cualquier otro usuario puede pulsar el
bot'on correspondiente y empezar'a un nuevo turno de dibujo, manteniendo las puntuaciones conseguidas previamente.

\textbf{Implementaci'on}

Esta aplicaci'on no ha sido programada desde cero, a diferencia de las dos anteriores, si no que se basa y hace uso de la aplicaci'on
Pictionary de Dave Frassoni\footnote{\url{http://davefrassoni.com}}. Afortunadamente, el autor especifica que su c'odigo es libre y puede ser modificado sin ning'un problema.
Adem'as se basa en tecnolog'ias que usamos en este proyecto, como son Javascript, Node.js y Socket.io.

Actualmente esta aplicaci'on est'a bajo desarrollo para poder ser adaptada a nuestras necesidades: uso de nuestra base de datos de japon'es,
generaci'on de estad'isticas, login de usuarios, etc.

Al ser una aplicaci'on multijugador de estas caracter'isticas, como puede suponerse existir'a una comunicaci'on frecuente entre cliente y
servidor. El lienzo de dibujo consiste en un canvas de HTML y cada nuevo trazo que se realiza en 'el es enviado al servidor mediante
Socket.io. El servidor registra este cambio en el lienzo y lo redirige al resto de usuarios.

\vspace{3em}
\begin{verbatim}
socket.on('draw', function (line) {
	if(currentPlayer == socket.id) {
		canvas.push(line);
		socket.broadcast.emit('draw', line);
	}
});
\end{verbatim}

Al contrario que las aplicaciones anteriores, este Pictionary no utilizar'a la biblioteca de dibujo CreateJS, puesto que su funcionamiento
no se asemeja al de un minijuego 2D donde haya que mover objetos en la pantalla, si no que se basa en env'io de datos entre un cliente y los dem'as.
